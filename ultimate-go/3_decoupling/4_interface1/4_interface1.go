package main

import "fmt"

// --------------
// Valueless type
// --------------

// reader는 데이터를 읽는 동작을 정의하는 인터페이스이다.
// 인터페이스는 엄밀히 말해서 값이 없는 타입이다.
// 이 인터페이스는 어떠한 멤버 변수도 가지지 않으며, 오직 행동에 대한 계약(contract)만을 정의한다.
// Go에서는 이 행동에 대한 계약을 통해서, 다형성(polymorphism)을 활용할 수 있다.
// 인터페이스는 두 개의 워드로 이루어진 자료 구조로, 두 워드 모두 포인터이다.
// 인터페이스는 참조 타입으로, var r reader 구문은 nil 값 가지는 인터페이스 r을 만든다.
type reader interface {
	read(b []byte) (int, error) // (1)

	// read 메서드를 다르게 정의할 수도 있다.
	// 예를 들어 read(i int) ([]byte, error) // (2) 처럼,
	// 파라미터로 읽을 바이트 수를 받고, 읽은 데이터를 슬라이스에 담아 에러와 함께 반환할 수도 있다.
	//
	// 그럼 왜 (1)을 선택한 것일까?
	//
	// (2)는 매번 호출할 때마다, 반환할 슬라이스를 메서드 내부에서 만들어야 한다.
	// 이때 슬라이스를 위한 배열을 힙 메모리에 할당하는 비용이 발생한다.
	// 하지만 (1)의 경우, 이 메서드를 호출하는 쪽에서 슬라이스를 만들 책임이 있다.
	// 따라서 슬라이스를 위한 한 번의 메모리 할당은 피할 수 없지만, 반복적인 메서드 호출에 대해 추가적인 메모리 할당은 발생하지 않는다.
}

// -------------------------------
// Concrete type vs Interface type
// -------------------------------

// 구체적 타입(concrete type)이란 메서드를 가질 수 있는 모든 타입을 말한다. 오직 사용자 정의 타입만이 메서드를 가질 수 있다.
// 메서드는 데이터가 인터페이스를 기반으로 기능을 외부에서 사용할 수 있도록 해준다. file은 시스템 파일을 위한 구조체이다.

type file struct {
	name string
}

// 이는 구체적 타입으로, 이후에 설명할 read 메서드를 가지고 있다.
// 이는 reader 인터페이스에서 선언한 메서드와 동일하다.
// 따라서, 구체적 타입인 file은 reader 인터페이스를 값 리시버를 이용해서 구현(implement) 한 것이다.
//
// 구현을 위해서 특별한 문법이 존재하는 것은 아니다. 다만 컴파일러가 자동으로 구현임을 인지한다.

// ------------
// Relationship
// ------------

// 인터페이스 변수에는 구체적 타입의 값을 저장할 수 있다.
// read는 file 타입에 대하여 reader 인터페이스를 구현한다.
func (file) read(b []byte) (int, error) {
	s := "<rss><channel><title>Going Go Programming</title></channel></rss>"
	copy(b, s)
	return len(s), nil
}

// pipe는 이름 있는 파이프 네트워크 연결을 위한 구조체이다.
// 이는 두 번째 구체적 타입으로, 값 리시버를 사용한다.
// 두 구체적 타입 모두 reader 인터페이스의 행동에 대한 계약을 구현하고 이들을 외부에 제공한다.
type pipe struct {
	name string
}

// read는 네트워크 연결을 위한 reader 인터페이스를 구현한다.
func (pipe) read(b []byte) (int, error) {
	s := `{name: "devnori", title: "developer"}`
	copy(b, s)
	return len(s), nil
}

func main() {
	// file과 pipe 두 타입의 변수를 다음과 같이 만들어보자.
	f := file{"data.json"}
	p := pipe{"cfg_service"}

	// 이 변수들을 파라미터로 retrieve 함수를 호출해보자.
	// 이 함수는 값을 파라미터로 받으므로, f의 복사본이 함수에서 사용된다.
	// 컴파일러는 다음의 질문을 하게 된다:
	// "이 변수의 타입 file은 reader 인터페이스를 구현한 것인가?"
	// file 타입은 reader 인터페이스의 행동에 대한 계약을 값 리시버를 이용하여 구현하였으므로, 이 질문에 대한 답은 “Yes”이다.
	// 이 예제에서, 인터페이스의 두 번째 워드는 f의 복사본을 가리킨다. 그리고 첫 번째 워드는 iTable이라는 특별한 자료 구조를 가리킨다.
	// iTable은 다음의 두 가지를 제공한다:
	// - 첫 번째 부분은 저장된 데이터의 타입을 나타낸다. 이 예제에서는 file 타입을 말한다.
	// - 두 번째 부분은 함수 포인터의 모체로서, 인터페이스를 통해 메서드를 호출할 때 정확한 메서드를 호출하기 위하여 사용된다.

	//       reader           iTable
	//    -----------        --------
	//   |           |      |  file  |
	//   |     *     | -->   --------
	//   |           |      |   *    | --> code
	//    -----------        --------
	//   |           |       --------
	//   |     *     | -->  | f copy | --> read()
	//   |           |       --------
	//    -----------

	// 인터페이스를 통해서 read를 호출하면, iTable을 확인해서 이 타입에 맞는 read 함수를 찾고 이를 호출한다.
	// 결과적으로 구체적 타입의 read 메서드를 호출하는 것이다.
	retrieve(f)

	// p도 이와 동일하다. reader 인터페이스의 첫 번째 워드는 pipe 타입을 가리키고, 두번째 워드는 p의 복사본을 가리킨다.

	//       reader           iTable
	//    -----------        -------
	//   |           |      |  pipe  |
	//   |     *     | -->   -------
	//   |           |      |   *    | --> code
	//    -----------        --------
	//   |           |       --------
	//   |     *     | -->  | p copy | --> read()
	//   |           |       --------
	//    -----------

	// 데이터가 변경되었기 때문에, 동작도 다르다.
	retrieve(p)

	// Important note:
	// 앞으로 iTable 과 이를 가리키는 포인터를 간략하게 *pipe 처럼 나타낼 것이다.
	//  -------
	// | *pipe |
	//  -------
	// |   *   |  --> p copy
	//  -------
}

// --------------------
// Polymorphic function
// --------------------

// retrieve 는 어떤 장치든 다 읽을 수 있고, 어떤 데이터든지 다 처리할 수 있다.
// 이러한 함수를 다형성 함수라 한다. 이 예제에서 사용된 파라미터는 reader 타입이다.
// 하지만 이는 인터페이스이므로 값이 없는 타입니다.
// 즉, 이 함수는 reader 인터페이스의 계약을 구현한 모든 타입을 다 파라미터로 받을 수 있다.
// 이 함수는 구체적 타입에 대해서는 전혀 알지 못하므로, 이는 완전히 디커플링 되어 있다.
// 이는 Go 에서 할 수 있는 최상위의 디커플링이다. 이러한 구현 방법은 간결하고 효율적이다.
// 이 방법을 사용하기 위해 필요한 것은 오직 인터페이스를 통한 구체적 타입 데이터로의 간접적 접근뿐이다.
func retrieve(r reader) error {
	data := make([]byte, 100)

	len, err := r.read(data)
	if err != nil {
		return err
	}

	fmt.Println(string(data[:len]))
	return nil
}
